// This file was auto-generated by Fern from our API Definition.

package webscan

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/Method-Security/webscan/generated/go/core"
	time "time"
)

type HttpMethod string

const (
	HttpMethodGet     HttpMethod = "GET"
	HttpMethodPost    HttpMethod = "POST"
	HttpMethodPut     HttpMethod = "PUT"
	HttpMethodDelete  HttpMethod = "DELETE"
	HttpMethodPatch   HttpMethod = "PATCH"
	HttpMethodOptions HttpMethod = "OPTIONS"
	HttpMethodHead    HttpMethod = "HEAD"
	HttpMethodConnect HttpMethod = "CONNECT"
	HttpMethodTrace   HttpMethod = "TRACE"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "DELETE":
		return HttpMethodDelete, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "OPTIONS":
		return HttpMethodOptions, nil
	case "HEAD":
		return HttpMethodHead, nil
	case "CONNECT":
		return HttpMethodConnect, nil
	case "TRACE":
		return HttpMethodTrace, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type TlsVersion string

const (
	TlsVersionSsl10   TlsVersion = "SSL10"
	TlsVersionSsl20   TlsVersion = "SSL20"
	TlsVersionSsl30   TlsVersion = "SSL30"
	TlsVersionTls10   TlsVersion = "TLS10"
	TlsVersionTls11   TlsVersion = "TLS11"
	TlsVersionTls12   TlsVersion = "TLS12"
	TlsVersionTls13   TlsVersion = "TLS13"
	TlsVersionUnknown TlsVersion = "UNKNOWN"
)

func NewTlsVersionFromString(s string) (TlsVersion, error) {
	switch s {
	case "SSL10":
		return TlsVersionSsl10, nil
	case "SSL20":
		return TlsVersionSsl20, nil
	case "SSL30":
		return TlsVersionSsl30, nil
	case "TLS10":
		return TlsVersionTls10, nil
	case "TLS11":
		return TlsVersionTls11, nil
	case "TLS12":
		return TlsVersionTls12, nil
	case "TLS13":
		return TlsVersionTls13, nil
	case "UNKNOWN":
		return TlsVersionUnknown, nil
	}
	var t TlsVersion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TlsVersion) Ptr() *TlsVersion {
	return &t
}

type Certificate struct {
	SubjectCommonName  *string             `json:"subjectCommonName,omitempty" url:"subjectCommonName,omitempty"`
	IssuerCommonName   *string             `json:"issuerCommonName,omitempty" url:"issuerCommonName,omitempty"`
	ValidFrom          *time.Time          `json:"validFrom,omitempty" url:"validFrom,omitempty"`
	ValidTo            *time.Time          `json:"validTo,omitempty" url:"validTo,omitempty"`
	Version            *int                `json:"version,omitempty" url:"version,omitempty"`
	SerialNumber       *string             `json:"serialNumber,omitempty" url:"serialNumber,omitempty"`
	Certificate        *string             `json:"certificate,omitempty" url:"certificate,omitempty"`
	Signature          *string             `json:"signature,omitempty" url:"signature,omitempty"`
	SignatureAlgorithm *SignatureAlgorithm `json:"signatureAlgorithm,omitempty" url:"signatureAlgorithm,omitempty"`
	PublicKeyAlgorithm *PublicKeyAlgorithm `json:"publicKeyAlgorithm,omitempty" url:"publicKeyAlgorithm,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Certificate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Certificate) UnmarshalJSON(data []byte) error {
	type embed Certificate
	var unmarshaler = struct {
		embed
		ValidFrom *core.DateTime `json:"validFrom,omitempty"`
		ValidTo   *core.DateTime `json:"validTo,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Certificate(unmarshaler.embed)
	c.ValidFrom = unmarshaler.ValidFrom.TimePtr()
	c.ValidTo = unmarshaler.ValidTo.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Certificate) MarshalJSON() ([]byte, error) {
	type embed Certificate
	var marshaler = struct {
		embed
		ValidFrom *core.DateTime `json:"validFrom,omitempty"`
		ValidTo   *core.DateTime `json:"validTo,omitempty"`
	}{
		embed:     embed(*c),
		ValidFrom: core.NewOptionalDateTime(c.ValidFrom),
		ValidTo:   core.NewOptionalDateTime(c.ValidTo),
	}
	return json.Marshal(marshaler)
}

func (c *Certificate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type FingerprintReport struct {
	Target              string       `json:"target" url:"target"`
	HttpHeaders         *HttpHeaders `json:"httpHeaders,omitempty" url:"httpHeaders,omitempty"`
	TlsInfo             *TlsInfo     `json:"tlsInfo,omitempty" url:"tlsInfo,omitempty"`
	RedirectUrl         *string      `json:"redirectUrl,omitempty" url:"redirectUrl,omitempty"`
	RedirectHttpHeaders *HttpHeaders `json:"redirectHttpHeaders,omitempty" url:"redirectHttpHeaders,omitempty"`
	RedirectTlsInfo     *TlsInfo     `json:"redirectTlsInfo,omitempty" url:"redirectTlsInfo,omitempty"`
	Errors              []string     `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FingerprintReport) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FingerprintReport) UnmarshalJSON(data []byte) error {
	type unmarshaler FingerprintReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FingerprintReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FingerprintReport) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type HttpHeaders struct {
	Location                  *string `json:"location,omitempty" url:"location,omitempty"`
	Server                    *string `json:"server,omitempty" url:"server,omitempty"`
	XPoweredBy                *string `json:"xPoweredBy,omitempty" url:"xPoweredBy,omitempty"`
	XFrameOptions             *string `json:"xFrameOptions,omitempty" url:"xFrameOptions,omitempty"`
	XClusterName              *string `json:"xClusterName,omitempty" url:"xClusterName,omitempty"`
	CrossOriginResourcePolicy *string `json:"crossOriginResourcePolicy,omitempty" url:"crossOriginResourcePolicy,omitempty"`
	AccessControlAllowOrigin  *string `json:"accessControlAllowOrigin,omitempty" url:"accessControlAllowOrigin,omitempty"`
	XAspNetVersion            *string `json:"xAspNetVersion,omitempty" url:"xAspNetVersion,omitempty"`
	AllowedHttpMethods        *string `json:"allowedHttpMethods,omitempty" url:"allowedHttpMethods,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpHeaders) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpHeaders) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpHeaders
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpHeaders(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HttpHeaders) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type PublicKeyAlgorithm string

const (
	PublicKeyAlgorithmRsa     PublicKeyAlgorithm = "RSA"
	PublicKeyAlgorithmDsa     PublicKeyAlgorithm = "DSA"
	PublicKeyAlgorithmEcdsa   PublicKeyAlgorithm = "ECDSA"
	PublicKeyAlgorithmEd25519 PublicKeyAlgorithm = "Ed25519"
	PublicKeyAlgorithmUnknown PublicKeyAlgorithm = "Unknown"
)

func NewPublicKeyAlgorithmFromString(s string) (PublicKeyAlgorithm, error) {
	switch s {
	case "RSA":
		return PublicKeyAlgorithmRsa, nil
	case "DSA":
		return PublicKeyAlgorithmDsa, nil
	case "ECDSA":
		return PublicKeyAlgorithmEcdsa, nil
	case "Ed25519":
		return PublicKeyAlgorithmEd25519, nil
	case "Unknown":
		return PublicKeyAlgorithmUnknown, nil
	}
	var t PublicKeyAlgorithm
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PublicKeyAlgorithm) Ptr() *PublicKeyAlgorithm {
	return &p
}

type SignatureAlgorithm string

const (
	SignatureAlgorithmMd2Rsa       SignatureAlgorithm = "MD2RSA"
	SignatureAlgorithmMd5Rsa       SignatureAlgorithm = "MD5RSA"
	SignatureAlgorithmSha1Rsa      SignatureAlgorithm = "SHA1RSA"
	SignatureAlgorithmSha256Rsa    SignatureAlgorithm = "SHA256RSA"
	SignatureAlgorithmSha384Rsa    SignatureAlgorithm = "SHA384RSA"
	SignatureAlgorithmSha512Rsa    SignatureAlgorithm = "SHA512RSA"
	SignatureAlgorithmDsasha1      SignatureAlgorithm = "DSASHA1"
	SignatureAlgorithmDsasha256    SignatureAlgorithm = "DSASHA256"
	SignatureAlgorithmEcdsasha1    SignatureAlgorithm = "ECDSASHA1"
	SignatureAlgorithmEcdsasha256  SignatureAlgorithm = "ECDSASHA256"
	SignatureAlgorithmEcdsasha384  SignatureAlgorithm = "ECDSASHA384"
	SignatureAlgorithmEcdsasha512  SignatureAlgorithm = "ECDSASHA512"
	SignatureAlgorithmSha256Rsapss SignatureAlgorithm = "SHA256RSAPSS"
	SignatureAlgorithmSha384Rsapss SignatureAlgorithm = "SHA384RSAPSS"
	SignatureAlgorithmSha512Rsapss SignatureAlgorithm = "SHA512RSAPSS"
	SignatureAlgorithmEd25519      SignatureAlgorithm = "Ed25519"
)

func NewSignatureAlgorithmFromString(s string) (SignatureAlgorithm, error) {
	switch s {
	case "MD2RSA":
		return SignatureAlgorithmMd2Rsa, nil
	case "MD5RSA":
		return SignatureAlgorithmMd5Rsa, nil
	case "SHA1RSA":
		return SignatureAlgorithmSha1Rsa, nil
	case "SHA256RSA":
		return SignatureAlgorithmSha256Rsa, nil
	case "SHA384RSA":
		return SignatureAlgorithmSha384Rsa, nil
	case "SHA512RSA":
		return SignatureAlgorithmSha512Rsa, nil
	case "DSASHA1":
		return SignatureAlgorithmDsasha1, nil
	case "DSASHA256":
		return SignatureAlgorithmDsasha256, nil
	case "ECDSASHA1":
		return SignatureAlgorithmEcdsasha1, nil
	case "ECDSASHA256":
		return SignatureAlgorithmEcdsasha256, nil
	case "ECDSASHA384":
		return SignatureAlgorithmEcdsasha384, nil
	case "ECDSASHA512":
		return SignatureAlgorithmEcdsasha512, nil
	case "SHA256RSAPSS":
		return SignatureAlgorithmSha256Rsapss, nil
	case "SHA384RSAPSS":
		return SignatureAlgorithmSha384Rsapss, nil
	case "SHA512RSAPSS":
		return SignatureAlgorithmSha512Rsapss, nil
	case "Ed25519":
		return SignatureAlgorithmEd25519, nil
	}
	var t SignatureAlgorithm
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SignatureAlgorithm) Ptr() *SignatureAlgorithm {
	return &s
}

type TlsInfo struct {
	Version      *TlsVersion    `json:"version,omitempty" url:"version,omitempty"`
	CipherSuite  *string        `json:"cipherSuite,omitempty" url:"cipherSuite,omitempty"`
	Certificates []*Certificate `json:"certificates,omitempty" url:"certificates,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TlsInfo) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TlsInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler TlsInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TlsInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TlsInfo) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type FuzzPathReport struct {
	Target                   string        `json:"target" url:"target"`
	Urls                     []*UrlDetails `json:"urls,omitempty" url:"urls,omitempty"`
	UrlsSkippedFromBaseMatch []*UrlDetails `json:"urlsSkippedFromBaseMatch,omitempty" url:"urlsSkippedFromBaseMatch,omitempty"`
	Errors                   []string      `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FuzzPathReport) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FuzzPathReport) UnmarshalJSON(data []byte) error {
	type unmarshaler FuzzPathReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FuzzPathReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FuzzPathReport) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type UrlDetails struct {
	Url    string `json:"url" url:"url"`
	Status string `json:"status" url:"status"`
	Size   int    `json:"size" url:"size"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UrlDetails) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UrlDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler UrlDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UrlDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UrlDetails) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type GraphQlData struct {
	Schema *GraphQlSchemaData `json:"__schema,omitempty" url:"__schema,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GraphQlData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphQlData) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphQlData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphQlData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphQlData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphQlField struct {
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GraphQlField) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphQlField) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphQlField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphQlField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphQlField) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphQlQuery struct {
	Type   string   `json:"type" url:"type"`
	Fields []string `json:"fields,omitempty" url:"fields,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GraphQlQuery) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphQlQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphQlQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphQlQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphQlQuery) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphQlSchema struct {
	Data *GraphQlData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GraphQlSchema) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphQlSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphQlSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphQlSchema(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphQlSchema) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphQlSchemaData struct {
	Types []*GraphQlType `json:"types,omitempty" url:"types,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GraphQlSchemaData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphQlSchemaData) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphQlSchemaData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphQlSchemaData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphQlSchemaData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphQlType struct {
	Name        string          `json:"name" url:"name"`
	Kind        string          `json:"kind" url:"kind"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Fields      []*GraphQlField `json:"fields,omitempty" url:"fields,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GraphQlType) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphQlType) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphQlType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphQlType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphQlType) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PageCaptureReport struct {
	Target      string   `json:"target" url:"target"`
	HtmlEncoded *string  `json:"html_encoded,omitempty" url:"html_encoded,omitempty"`
	Errors      []string `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PageCaptureReport) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PageCaptureReport) UnmarshalJSON(data []byte) error {
	type unmarshaler PageCaptureReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PageCaptureReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PageCaptureReport) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PageScreenshotReport struct {
	Target      string   `json:"target" url:"target"`
	HtmlEncoded *string  `json:"html_encoded,omitempty" url:"html_encoded,omitempty"`
	Screenshot  []byte   `json:"screenshot" url:"screenshot"`
	Errors      []string `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PageScreenshotReport) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PageScreenshotReport) UnmarshalJSON(data []byte) error {
	type unmarshaler PageScreenshotReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PageScreenshotReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PageScreenshotReport) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Attempt struct {
	Name        ModuleName        `json:"name" url:"name"`
	Timestamp   time.Time         `json:"timestamp" url:"timestamp"`
	AttemptInfo *AttemptInfoUnion `json:"AttemptInfo,omitempty" url:"AttemptInfo,omitempty"`
	Finding     bool              `json:"finding" url:"finding"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Attempt) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Attempt) UnmarshalJSON(data []byte) error {
	type embed Attempt
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Attempt(unmarshaler.embed)
	a.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Attempt) MarshalJSON() ([]byte, error) {
	type embed Attempt
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*a),
		Timestamp: core.NewDateTime(a.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (a *Attempt) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttemptInfoUnion struct {
	Type                 string
	MultiplePathsAttempt *MultiplePathsAttemptInfo
	GeneralAttempt       *GeneralAttemptInfo
	VersionAttempt       *VersionEnumerateAttemptInfo
}

func NewAttemptInfoUnionFromMultiplePathsAttempt(value *MultiplePathsAttemptInfo) *AttemptInfoUnion {
	return &AttemptInfoUnion{Type: "MultiplePathsAttempt", MultiplePathsAttempt: value}
}

func NewAttemptInfoUnionFromGeneralAttempt(value *GeneralAttemptInfo) *AttemptInfoUnion {
	return &AttemptInfoUnion{Type: "GeneralAttempt", GeneralAttempt: value}
}

func NewAttemptInfoUnionFromVersionAttempt(value *VersionEnumerateAttemptInfo) *AttemptInfoUnion {
	return &AttemptInfoUnion{Type: "VersionAttempt", VersionAttempt: value}
}

func (a *AttemptInfoUnion) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "MultiplePathsAttempt":
		value := new(MultiplePathsAttemptInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.MultiplePathsAttempt = value
	case "GeneralAttempt":
		value := new(GeneralAttemptInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.GeneralAttempt = value
	case "VersionAttempt":
		value := new(VersionEnumerateAttemptInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.VersionAttempt = value
	}
	return nil
}

func (a AttemptInfoUnion) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "MultiplePathsAttempt":
		return core.MarshalJSONWithExtraProperty(a.MultiplePathsAttempt, "type", "MultiplePathsAttempt")
	case "GeneralAttempt":
		return core.MarshalJSONWithExtraProperty(a.GeneralAttempt, "type", "GeneralAttempt")
	case "VersionAttempt":
		return core.MarshalJSONWithExtraProperty(a.VersionAttempt, "type", "VersionAttempt")
	}
}

type AttemptInfoUnionVisitor interface {
	VisitMultiplePathsAttempt(*MultiplePathsAttemptInfo) error
	VisitGeneralAttempt(*GeneralAttemptInfo) error
	VisitVersionAttempt(*VersionEnumerateAttemptInfo) error
}

func (a *AttemptInfoUnion) Accept(visitor AttemptInfoUnionVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "MultiplePathsAttempt":
		return visitor.VisitMultiplePathsAttempt(a.MultiplePathsAttempt)
	case "GeneralAttempt":
		return visitor.VisitGeneralAttempt(a.GeneralAttempt)
	case "VersionAttempt":
		return visitor.VisitVersionAttempt(a.VersionAttempt)
	}
}

type GeneralAttemptInfo struct {
	Request  *GeneralRequestInfo  `json:"request,omitempty" url:"request,omitempty"`
	Response *GeneralResponseInfo `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GeneralAttemptInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneralAttemptInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneralAttemptInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneralAttemptInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeneralAttemptInfo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneralRequestInfo struct {
	Method  HttpMethod        `json:"method" url:"method"`
	Url     string            `json:"url" url:"url"`
	Headers map[string]string `json:"headers,omitempty" url:"headers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GeneralRequestInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneralRequestInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneralRequestInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneralRequestInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeneralRequestInfo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneralResponseInfo struct {
	StatusCode int     `json:"statusCode" url:"statusCode"`
	Body       *string `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GeneralResponseInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneralResponseInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneralResponseInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneralResponseInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeneralResponseInfo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ModuleName string

const (
	ModuleNameBufferOverflowContentHeader  ModuleName = "BUFFER_OVERFLOW_CONTENT_HEADER"
	ModuleNamePathTraversal                ModuleName = "PATH_TRAVERSAL"
	ModuleNameRceModFile                   ModuleName = "RCE_MOD_FILE"
	ModuleNameReverseProxyMisconfiguration ModuleName = "REVERSE_PROXY_MISCONFIGURATION"
	ModuleNameXPoweredByHeaderGrab         ModuleName = "X_POWERED_BY_HEADER_GRAB"
)

func NewModuleNameFromString(s string) (ModuleName, error) {
	switch s {
	case "BUFFER_OVERFLOW_CONTENT_HEADER":
		return ModuleNameBufferOverflowContentHeader, nil
	case "PATH_TRAVERSAL":
		return ModuleNamePathTraversal, nil
	case "RCE_MOD_FILE":
		return ModuleNameRceModFile, nil
	case "REVERSE_PROXY_MISCONFIGURATION":
		return ModuleNameReverseProxyMisconfiguration, nil
	case "X_POWERED_BY_HEADER_GRAB":
		return ModuleNameXPoweredByHeaderGrab, nil
	}
	var t ModuleName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ModuleName) Ptr() *ModuleName {
	return &m
}

type MultiplePathsAttemptInfo struct {
	Paths []*PathInfo `json:"paths,omitempty" url:"paths,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MultiplePathsAttemptInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultiplePathsAttemptInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MultiplePathsAttemptInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultiplePathsAttemptInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultiplePathsAttemptInfo) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PathInfo struct {
	Path     string               `json:"path" url:"path"`
	Request  *GeneralRequestInfo  `json:"request,omitempty" url:"request,omitempty"`
	Response *GeneralResponseInfo `json:"response,omitempty" url:"response,omitempty"`
	Finding  *bool                `json:"finding,omitempty" url:"finding,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PathInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PathInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PathInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PathInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PathInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProbeType string

const (
	ProbeTypeEnumeration ProbeType = "ENUMERATION"
	ProbeTypeValidation  ProbeType = "VALIDATION"
)

func NewProbeTypeFromString(s string) (ProbeType, error) {
	switch s {
	case "ENUMERATION":
		return ProbeTypeEnumeration, nil
	case "VALIDATION":
		return ProbeTypeValidation, nil
	}
	var t ProbeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProbeType) Ptr() *ProbeType {
	return &p
}

type ResponseUnion struct {
	Type                     string
	GeneralResponse          *GeneralResponseInfo
	VersionEnumerateResponse *VersionEnumerateResponseInfo
}

func NewResponseUnionFromGeneralResponse(value *GeneralResponseInfo) *ResponseUnion {
	return &ResponseUnion{Type: "GeneralResponse", GeneralResponse: value}
}

func NewResponseUnionFromVersionEnumerateResponse(value *VersionEnumerateResponseInfo) *ResponseUnion {
	return &ResponseUnion{Type: "VersionEnumerateResponse", VersionEnumerateResponse: value}
}

func (r *ResponseUnion) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "GeneralResponse":
		value := new(GeneralResponseInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.GeneralResponse = value
	case "VersionEnumerateResponse":
		value := new(VersionEnumerateResponseInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.VersionEnumerateResponse = value
	}
	return nil
}

func (r ResponseUnion) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "GeneralResponse":
		return core.MarshalJSONWithExtraProperty(r.GeneralResponse, "type", "GeneralResponse")
	case "VersionEnumerateResponse":
		return core.MarshalJSONWithExtraProperty(r.VersionEnumerateResponse, "type", "VersionEnumerateResponse")
	}
}

type ResponseUnionVisitor interface {
	VisitGeneralResponse(*GeneralResponseInfo) error
	VisitVersionEnumerateResponse(*VersionEnumerateResponseInfo) error
}

func (r *ResponseUnion) Accept(visitor ResponseUnionVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "GeneralResponse":
		return visitor.VisitGeneralResponse(r.GeneralResponse)
	case "VersionEnumerateResponse":
		return visitor.VisitVersionEnumerateResponse(r.VersionEnumerateResponse)
	}
}

type ServerType string

const (
	ServerTypeApache ServerType = "APACHE"
	ServerTypeNginx  ServerType = "NGINX"
)

func NewServerTypeFromString(s string) (ServerType, error) {
	switch s {
	case "APACHE":
		return ServerTypeApache, nil
	case "NGINX":
		return ServerTypeNginx, nil
	}
	var t ServerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerType) Ptr() *ServerType {
	return &s
}

type VersionEnumerateAttemptInfo struct {
	Request  *GeneralRequestInfo           `json:"request,omitempty" url:"request,omitempty"`
	Response *VersionEnumerateResponseInfo `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VersionEnumerateAttemptInfo) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VersionEnumerateAttemptInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler VersionEnumerateAttemptInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VersionEnumerateAttemptInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VersionEnumerateAttemptInfo) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VersionEnumerateResponseInfo struct {
	StatusCode    int     `json:"statusCode" url:"statusCode"`
	Header        *string `json:"header,omitempty" url:"header,omitempty"`
	VersionType   *string `json:"versionType,omitempty" url:"versionType,omitempty"`
	VersionNumber *string `json:"versionNumber,omitempty" url:"versionNumber,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VersionEnumerateResponseInfo) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VersionEnumerateResponseInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler VersionEnumerateResponseInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VersionEnumerateResponseInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VersionEnumerateResponseInfo) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WebserverProbe struct {
	Target   string     `json:"target" url:"target"`
	Attempts []*Attempt `json:"attempts,omitempty" url:"attempts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebserverProbe) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebserverProbe) UnmarshalJSON(data []byte) error {
	type unmarshaler WebserverProbe
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebserverProbe(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebserverProbe) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebserverProbeReport struct {
	Server          ServerType        `json:"server" url:"server"`
	Probe           ProbeType         `json:"probe" url:"probe"`
	WebserverProbes []*WebserverProbe `json:"webserverProbes,omitempty" url:"webserverProbes,omitempty"`
	Errors          []string          `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebserverProbeReport) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebserverProbeReport) UnmarshalJSON(data []byte) error {
	type unmarshaler WebserverProbeReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebserverProbeReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebserverProbeReport) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type ProbeTypeConfig struct {
	Targets        []string   `json:"targets,omitempty" url:"targets,omitempty"`
	Server         ServerType `json:"server" url:"server"`
	Probe          ProbeType  `json:"probe" url:"probe"`
	Timeout        int        `json:"timeout" url:"timeout"`
	SuccessfulOnly bool       `json:"successfulOnly" url:"successfulOnly"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProbeTypeConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProbeTypeConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ProbeTypeConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProbeTypeConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProbeTypeConfig) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ParsedParams struct {
	PathParams      map[string]string `json:"pathParams,omitempty" url:"pathParams,omitempty"`
	QueryParams     map[string]string `json:"queryParams,omitempty" url:"queryParams,omitempty"`
	HeaderParams    map[string]string `json:"headerParams,omitempty" url:"headerParams,omitempty"`
	BodyParams      string            `json:"bodyParams" url:"bodyParams"`
	FormParams      map[string]string `json:"formParams,omitempty" url:"formParams,omitempty"`
	MultipartParams map[string]string `json:"multipartParams,omitempty" url:"multipartParams,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ParsedParams) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ParsedParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ParsedParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParsedParams(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParsedParams) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RequestParams struct {
	PathParams      string `json:"pathParams" url:"pathParams"`
	QueryParams     string `json:"queryParams" url:"queryParams"`
	HeaderParams    string `json:"headerParams" url:"headerParams"`
	BodyParams      string `json:"bodyParams" url:"bodyParams"`
	FormParams      string `json:"formParams" url:"formParams"`
	MultipartParams string `json:"multipartParams" url:"multipartParams"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RequestParams) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RequestParams) UnmarshalJSON(data []byte) error {
	type unmarshaler RequestParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RequestParams(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RequestParams) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RequestReport struct {
	BaseUrl         string            `json:"baseUrl" url:"baseUrl"`
	Path            string            `json:"path" url:"path"`
	Method          HttpMethod        `json:"method" url:"method"`
	PathParams      map[string]string `json:"pathParams,omitempty" url:"pathParams,omitempty"`
	QueryParams     map[string]string `json:"queryParams,omitempty" url:"queryParams,omitempty"`
	HeaderParams    map[string]string `json:"headerParams,omitempty" url:"headerParams,omitempty"`
	BodyParams      *string           `json:"bodyParams,omitempty" url:"bodyParams,omitempty"`
	FormParams      map[string]string `json:"formParams,omitempty" url:"formParams,omitempty"`
	MultipartParams map[string]string `json:"multipartParams,omitempty" url:"multipartParams,omitempty"`
	VulnTypes       []VulnType        `json:"vulnTypes,omitempty" url:"vulnTypes,omitempty"`
	StatusCode      int               `json:"statusCode" url:"statusCode"`
	ResponseBody    string            `json:"responseBody" url:"responseBody"`
	ResponseHeaders map[string]string `json:"responseHeaders,omitempty" url:"responseHeaders,omitempty"`
	Errors          []string          `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RequestReport) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RequestReport) UnmarshalJSON(data []byte) error {
	type unmarshaler RequestReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RequestReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RequestReport) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type VulnType string

const (
	VulnTypeCommand        VulnType = "COMMAND"
	VulnTypeSql            VulnType = "SQL"
	VulnTypeXss            VulnType = "XSS"
	VulnTypeAuth           VulnType = "AUTH"
	VulnTypeSensitiveerror VulnType = "SENSITIVEERROR"
	VulnTypeSqlinjection   VulnType = "SQLINJECTION"
	VulnTypeTemplate       VulnType = "TEMPLATE"
	VulnTypeNosql          VulnType = "NOSQL"
)

func NewVulnTypeFromString(s string) (VulnType, error) {
	switch s {
	case "COMMAND":
		return VulnTypeCommand, nil
	case "SQL":
		return VulnTypeSql, nil
	case "XSS":
		return VulnTypeXss, nil
	case "AUTH":
		return VulnTypeAuth, nil
	case "SENSITIVEERROR":
		return VulnTypeSensitiveerror, nil
	case "SQLINJECTION":
		return VulnTypeSqlinjection, nil
	case "TEMPLATE":
		return VulnTypeTemplate, nil
	case "NOSQL":
		return VulnTypeNosql, nil
	}
	var t VulnType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VulnType) Ptr() *VulnType {
	return &v
}

type BodyParams struct {
	Name          string   `json:"name" url:"name"`
	ExampleValues []string `json:"exampleValues,omitempty" url:"exampleValues,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BodyParams) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyParams) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyParams(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BodyParams) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type PageCaptureMethod string

const (
	PageCaptureMethodRequest     PageCaptureMethod = "REQUEST"
	PageCaptureMethodBrowser     PageCaptureMethod = "BROWSER"
	PageCaptureMethodBrowserbase PageCaptureMethod = "BROWSERBASE"
)

func NewPageCaptureMethodFromString(s string) (PageCaptureMethod, error) {
	switch s {
	case "REQUEST":
		return PageCaptureMethodRequest, nil
	case "BROWSER":
		return PageCaptureMethodBrowser, nil
	case "BROWSERBASE":
		return PageCaptureMethodBrowserbase, nil
	}
	var t PageCaptureMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PageCaptureMethod) Ptr() *PageCaptureMethod {
	return &p
}

type QueryParams struct {
	Name          string   `json:"name" url:"name"`
	ExampleValues []string `json:"exampleValues,omitempty" url:"exampleValues,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryParams) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryParams) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryParams(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryParams) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type RouteCaptureReport struct {
	Target string      `json:"target" url:"target"`
	Routes []*WebRoute `json:"routes,omitempty" url:"routes,omitempty"`
	Urls   []string    `json:"urls,omitempty" url:"urls,omitempty"`
	Errors []string    `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RouteCaptureReport) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RouteCaptureReport) UnmarshalJSON(data []byte) error {
	type unmarshaler RouteCaptureReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RouteCaptureReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RouteCaptureReport) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type WebRoute struct {
	Url         string         `json:"url" url:"url"`
	Path        *string        `json:"path,omitempty" url:"path,omitempty"`
	Method      *HttpMethod    `json:"method,omitempty" url:"method,omitempty"`
	QueryParams []*QueryParams `json:"queryParams,omitempty" url:"queryParams,omitempty"`
	BodyParams  []*BodyParams  `json:"bodyParams,omitempty" url:"bodyParams,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebRoute) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebRoute) UnmarshalJSON(data []byte) error {
	type unmarshaler WebRoute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebRoute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebRoute) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type ApiType string

const (
	ApiTypeGrpc      ApiType = "Grpc"
	ApiTypeGraphQl   ApiType = "GraphQL"
	ApiTypeSwaggerV2 ApiType = "SwaggerV2"
	ApiTypeSwaggerV3 ApiType = "SwaggerV3"
)

func NewApiTypeFromString(s string) (ApiType, error) {
	switch s {
	case "Grpc":
		return ApiTypeGrpc, nil
	case "GraphQL":
		return ApiTypeGraphQl, nil
	case "SwaggerV2":
		return ApiTypeSwaggerV2, nil
	case "SwaggerV3":
		return ApiTypeSwaggerV3, nil
	}
	var t ApiType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApiType) Ptr() *ApiType {
	return &a
}

type OAuthFlow struct {
	AuthorizationUrl *string           `json:"authorizationUrl,omitempty" url:"authorizationUrl,omitempty"`
	TokenUrl         *string           `json:"tokenUrl,omitempty" url:"tokenUrl,omitempty"`
	RefreshUrl       *string           `json:"refreshUrl,omitempty" url:"refreshUrl,omitempty"`
	Scopes           map[string]string `json:"scopes,omitempty" url:"scopes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OAuthFlow) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthFlow) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthFlow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthFlow(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuthFlow) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuthFlows struct {
	Implicit          *OAuthFlow `json:"implicit,omitempty" url:"implicit,omitempty"`
	Password          *OAuthFlow `json:"password,omitempty" url:"password,omitempty"`
	ClientCredentials *OAuthFlow `json:"clientCredentials,omitempty" url:"clientCredentials,omitempty"`
	AuthorizationCode *OAuthFlow `json:"authorizationCode,omitempty" url:"authorizationCode,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OAuthFlows) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthFlows) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthFlows
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthFlows(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuthFlows) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type RequestSchema struct {
	Type                 []string          `json:"type,omitempty" url:"type,omitempty"`
	Properties           []*SchemaProperty `json:"properties,omitempty" url:"properties,omitempty"`
	Required             []string          `json:"required,omitempty" url:"required,omitempty"`
	Items                *RequestSchema    `json:"items,omitempty" url:"items,omitempty"`
	AdditionalProperties *RequestSchema    `json:"additionalProperties,omitempty" url:"additionalProperties,omitempty"`
	AllOf                []*RequestSchema  `json:"allOf,omitempty" url:"allOf,omitempty"`
	OneOf                []*RequestSchema  `json:"oneOf,omitempty" url:"oneOf,omitempty"`
	AnyOf                []*RequestSchema  `json:"anyOf,omitempty" url:"anyOf,omitempty"`
	Not                  *RequestSchema    `json:"not,omitempty" url:"not,omitempty"`
	Description          *string           `json:"description,omitempty" url:"description,omitempty"`
	Format               *string           `json:"format,omitempty" url:"format,omitempty"`
	Default              *string           `json:"default,omitempty" url:"default,omitempty"`
	Example              interface{}       `json:"example,omitempty" url:"example,omitempty"`
	Enum                 []interface{}     `json:"enum,omitempty" url:"enum,omitempty"`
	MultipleOf           *float64          `json:"multipleOf,omitempty" url:"multipleOf,omitempty"`
	Maximum              *float64          `json:"maximum,omitempty" url:"maximum,omitempty"`
	ExclusiveMaximum     *bool             `json:"exclusiveMaximum,omitempty" url:"exclusiveMaximum,omitempty"`
	Minimum              *float64          `json:"minimum,omitempty" url:"minimum,omitempty"`
	ExclusiveMinimum     *bool             `json:"exclusiveMinimum,omitempty" url:"exclusiveMinimum,omitempty"`
	MaxLength            *int              `json:"maxLength,omitempty" url:"maxLength,omitempty"`
	MinLength            *int              `json:"minLength,omitempty" url:"minLength,omitempty"`
	Pattern              *string           `json:"pattern,omitempty" url:"pattern,omitempty"`
	MaxItems             *int              `json:"maxItems,omitempty" url:"maxItems,omitempty"`
	MinItems             *int              `json:"minItems,omitempty" url:"minItems,omitempty"`
	UniqueItems          *bool             `json:"uniqueItems,omitempty" url:"uniqueItems,omitempty"`
	MaxProperties        *int              `json:"maxProperties,omitempty" url:"maxProperties,omitempty"`
	MinProperties        *int              `json:"minProperties,omitempty" url:"minProperties,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RequestSchema) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RequestSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler RequestSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RequestSchema(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RequestSchema) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Route struct {
	Path               string               `json:"path" url:"path"`
	QueryParams        []string             `json:"queryParams,omitempty" url:"queryParams,omitempty"`
	Security           *SecurityRequirement `json:"security,omitempty" url:"security,omitempty"`
	Method             string               `json:"method" url:"method"`
	Type               ApiType              `json:"type" url:"type"`
	Description        string               `json:"description" url:"description"`
	ResponseProperties map[string][]string  `json:"responseProperties,omitempty" url:"responseProperties,omitempty"`
	RequestSchema      *RequestSchema       `json:"requestSchema,omitempty" url:"requestSchema,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Route) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Route) UnmarshalJSON(data []byte) error {
	type unmarshaler Route
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Route(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Route) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoutesReport struct {
	Target          string                                 `json:"target" url:"target"`
	AppType         ApiType                                `json:"appType" url:"appType"`
	BaseEndpointUrl string                                 `json:"baseEndpointUrl" url:"baseEndpointUrl"`
	Version         *string                                `json:"version,omitempty" url:"version,omitempty"`
	SchemaUrl       *string                                `json:"schemaUrl,omitempty" url:"schemaUrl,omitempty"`
	Routes          []*Route                               `json:"routes,omitempty" url:"routes,omitempty"`
	SecuritySchemes map[SecuritySchemeName]*SecurityScheme `json:"securitySchemes,omitempty" url:"securitySchemes,omitempty"`
	Security        []*SecurityRequirement                 `json:"security,omitempty" url:"security,omitempty"`
	Queries         []*GraphQlQuery                        `json:"queries,omitempty" url:"queries,omitempty"`
	Raw             string                                 `json:"raw" url:"raw"`
	Errors          []string                               `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoutesReport) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoutesReport) UnmarshalJSON(data []byte) error {
	type unmarshaler RoutesReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoutesReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoutesReport) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SchemaProperty struct {
	Name                 string            `json:"name" url:"name"`
	Type                 []string          `json:"type,omitempty" url:"type,omitempty"`
	Format               *string           `json:"format,omitempty" url:"format,omitempty"`
	Description          *string           `json:"description,omitempty" url:"description,omitempty"`
	Required             *bool             `json:"required,omitempty" url:"required,omitempty"`
	Items                *RequestSchema    `json:"items,omitempty" url:"items,omitempty"`
	Properties           []*SchemaProperty `json:"properties,omitempty" url:"properties,omitempty"`
	AdditionalProperties *RequestSchema    `json:"additionalProperties,omitempty" url:"additionalProperties,omitempty"`
	Enum                 []string          `json:"enum,omitempty" url:"enum,omitempty"`
	Example              *string           `json:"example,omitempty" url:"example,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SchemaProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SchemaProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemaProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemaProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemaProperty) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SecurityRequirement struct {
	Schemes map[string][]string `json:"schemes,omitempty" url:"schemes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SecurityRequirement) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecurityRequirement) UnmarshalJSON(data []byte) error {
	type unmarshaler SecurityRequirement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecurityRequirement(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecurityRequirement) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SecurityScheme struct {
	Type             SecuritySchemeType  `json:"type" url:"type"`
	Description      *string             `json:"description,omitempty" url:"description,omitempty"`
	Name             *SecuritySchemeName `json:"name,omitempty" url:"name,omitempty"`
	In               *string             `json:"in,omitempty" url:"in,omitempty"`
	Scheme           *string             `json:"scheme,omitempty" url:"scheme,omitempty"`
	BearerFormat     *string             `json:"bearerFormat,omitempty" url:"bearerFormat,omitempty"`
	Flow             *string             `json:"flow,omitempty" url:"flow,omitempty"`
	AuthorizationUrl *string             `json:"authorizationUrl,omitempty" url:"authorizationUrl,omitempty"`
	TokenUrl         *string             `json:"tokenUrl,omitempty" url:"tokenUrl,omitempty"`
	Scopes           map[string]string   `json:"scopes,omitempty" url:"scopes,omitempty"`
	Flows            *OAuthFlows         `json:"flows,omitempty" url:"flows,omitempty"`
	OpenIdConnectUrl *string             `json:"openIdConnectUrl,omitempty" url:"openIdConnectUrl,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SecurityScheme) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecurityScheme) UnmarshalJSON(data []byte) error {
	type unmarshaler SecurityScheme
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecurityScheme(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecurityScheme) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SecuritySchemeName = string

type SecuritySchemeType string

const (
	SecuritySchemeTypeBasic         SecuritySchemeType = "basic"
	SecuritySchemeTypeApiKey        SecuritySchemeType = "apiKey"
	SecuritySchemeTypeHttp          SecuritySchemeType = "http"
	SecuritySchemeTypeOauth2        SecuritySchemeType = "oauth2"
	SecuritySchemeTypeOpenIdConnect SecuritySchemeType = "openIdConnect"
	SecuritySchemeTypeMutualTls     SecuritySchemeType = "mutualTLS"
)

func NewSecuritySchemeTypeFromString(s string) (SecuritySchemeType, error) {
	switch s {
	case "basic":
		return SecuritySchemeTypeBasic, nil
	case "apiKey":
		return SecuritySchemeTypeApiKey, nil
	case "http":
		return SecuritySchemeTypeHttp, nil
	case "oauth2":
		return SecuritySchemeTypeOauth2, nil
	case "openIdConnect":
		return SecuritySchemeTypeOpenIdConnect, nil
	case "mutualTLS":
		return SecuritySchemeTypeMutualTls, nil
	}
	var t SecuritySchemeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SecuritySchemeType) Ptr() *SecuritySchemeType {
	return &s
}
